/**
 * Given an exchange, recovers the list of trading positions open as of a specific block number.
 *
 * As positions are stored in a map in the `Exchange` contract, we can not just iterate over all the
 * positions.  Instead we read `ChangePosition` events generated by the exchange and recover the
 * active list based on that.
 */

import { IExchangeEvents } from "@generated/IExchangeEvents";
import { default as _ } from "lodash";
import { tryNTimes } from "utils";

export enum PositionState {
  Open,
  Closed,
}

export class Position {
  constructor(
    /// Block number where we observed latest action for this position.
    public block: number,
    /// Transaction number within the `block`, number where we observed latest action for this
    //position.
    public transaction: number,
    /// State observed in block `lastAction`.
    public state: PositionState
  ) {}
}

export interface Stats {
  open: number;
  closed: number;
}

/**
 * Maps a position to the latest state available about this position.
 */
export class Positions {
  constructor(
    public positions: {
      [address: string]: Position;
    } = {},
    public stats: Stats = { open: 0, closed: 0 }
  ) {}

  public async updateFrom(
    exchange: IExchangeEvents,
    fromBlock: number,
    toBlock: number
  ): Promise<void> {
    const { positions } = this;

    const eventFilter = exchange.filters.PositionChanged();
    const events = await tryNTimes(3, () =>
      exchange.queryFilter(eventFilter, fromBlock, toBlock)
    );

    for (const event of events) {
      const { args, blockNumber: block, transactionIndex: transaction } = event;
      const {
        trader: address,
        previousAsset,
        previousStable,
        newAsset,
        newStable,
      } = args;

      let state: PositionState;
      if (previousAsset.isZero() && previousStable.isZero()) {
        state = PositionState.Open;
      } else if (newAsset.isZero() && newStable.isZero()) {
        state = PositionState.Closed;
      } else {
        continue;
      }

      const position = positions[address];
      if (position === undefined) {
        positions[address] = new Position(block, transaction, state);
        this.updateStats(state, (v) => v + 1);
        continue;
      }

      if (
        position.block > block ||
        (position.block == block && position.transaction >= transaction)
      ) {
        continue;
      }

      this.updateStats(position.state, (v) => v - 1);
      position.block = block;
      position.transaction = transaction;
      position.state = state;
      this.updateStats(position.state, (v) => v + 1);
    }
  }

  private updateStats(
    state: PositionState,
    update: (counter: number) => number
  ) {
    switch (state) {
      case PositionState.Open:
        this.stats.open = update(this.stats.open);
        break;

      case PositionState.Closed:
        this.stats.closed = update(this.stats.closed);
        break;

      default:
        throw new Error(`Unexpected position state: ${state}`);
    }
  }

  public getOpen(): string[] {
    const { positions } = this;

    return Object.entries(positions)
      .filter(([_address, info]) => info.state == PositionState.Open)
      .map(([address, _info]) => address);
  }
}
